using UnityEngine;
using UnityEngine.Networking;
using System.Collections;
using System.Collections.Generic;
using HorizonMini.Data;
using HorizonMini.Core;
using HorizonMini.Build;

namespace HorizonMini.AI
{
    /// <summary>
    /// AI Scene Generator using OpenAI API
    /// Generates 3D scene layouts based on user prompts
    /// </summary>
    public class AISceneGenerator : MonoBehaviour
    {
        [Header("Configuration")]
        [SerializeField] private string openAIApiKey = "";
        [SerializeField] private string openAIModel = "gpt-4o-mini";
        [SerializeField] private TextAsset assetCatalogJsonFile; // JSON file generated by Editor tool

        [Header("Debug")]
        [SerializeField] private bool logApiCalls = true;

        private const string OPENAI_API_URL = "https://api.openai.com/v1/chat/completions";

        /// <summary>
        /// Generate scene based on user prompt
        /// </summary>
        public void GenerateScene(string userPrompt, Vector3Int volumeSize, Vector3 volumeCenter, System.Action<GeneratedScene> onSuccess, System.Action<string> onError, List<ExistingObjectInfo> existingObjects = null)
        {
            if (string.IsNullOrEmpty(openAIApiKey))
            {
                onError?.Invoke("OpenAI API Key not set! Please configure in AISceneGenerator component.");
                return;
            }

            if (assetCatalogJsonFile == null)
            {
                onError?.Invoke("AssetCatalog JSON file not assigned! Please assign the JSON TextAsset in Inspector.");
                return;
            }

            StartCoroutine(GenerateSceneCoroutine(userPrompt, volumeSize, volumeCenter, onSuccess, onError, existingObjects));
        }

        private IEnumerator GenerateSceneCoroutine(string userPrompt, Vector3Int volumeSize, Vector3 volumeCenter, System.Action<GeneratedScene> onSuccess, System.Action<string> onError, List<ExistingObjectInfo> existingObjects)
        {
            // Build OpenAI request
            string requestJson = BuildOpenAIRequest(userPrompt, volumeSize, volumeCenter, existingObjects);

            if (logApiCalls)
            {
                Debug.Log($"<color=cyan>[AISceneGenerator] Sending request to OpenAI:\n{requestJson}</color>");
            }

            // Create web request
            UnityWebRequest request = new UnityWebRequest(OPENAI_API_URL, "POST");
            byte[] bodyRaw = System.Text.Encoding.UTF8.GetBytes(requestJson);
            request.uploadHandler = new UploadHandlerRaw(bodyRaw);
            request.downloadHandler = new DownloadHandlerBuffer();
            request.SetRequestHeader("Content-Type", "application/json");
            request.SetRequestHeader("Authorization", $"Bearer {openAIApiKey}");

            // Send request
            yield return request.SendWebRequest();

            // Handle response
            if (request.result != UnityWebRequest.Result.Success)
            {
                string errorMsg = $"OpenAI API Error: {request.error}\n{request.downloadHandler.text}";
                Debug.LogError($"<color=red>[AISceneGenerator] {errorMsg}</color>");
                onError?.Invoke(errorMsg);
                yield break;
            }

            // Parse response
            string responseText = request.downloadHandler.text;

            if (logApiCalls)
            {
                Debug.Log($"<color=green>[AISceneGenerator] Received response from OpenAI:\n{responseText}</color>");
            }

            try
            {
                OpenAIResponse response = JsonUtility.FromJson<OpenAIResponse>(responseText);

                if (response.choices == null || response.choices.Length == 0)
                {
                    onError?.Invoke("OpenAI returned empty response");
                    yield break;
                }

                string contentJson = response.choices[0].message.content;

                // Remove markdown code blocks if present
                contentJson = contentJson.Trim();
                if (contentJson.StartsWith("```json"))
                {
                    contentJson = contentJson.Substring(7);
                }
                if (contentJson.StartsWith("```"))
                {
                    contentJson = contentJson.Substring(3);
                }
                if (contentJson.EndsWith("```"))
                {
                    contentJson = contentJson.Substring(0, contentJson.Length - 3);
                }
                contentJson = contentJson.Trim();

                // Fix common JSON formatting errors from LLM
                contentJson = FixCommonJsonErrors(contentJson);

                // Check if JSON was truncated (finish_reason: length)
                bool wasTruncated = response.choices[0].finish_reason == "length";
                if (wasTruncated)
                {
                    Debug.LogWarning("<color=yellow>[AISceneGenerator] Response was truncated! Attempting to fix incomplete JSON...</color>");

                    // Try to close the JSON array and object if truncated
                    contentJson = FixTruncatedJson(contentJson);
                }

                Debug.Log($"<color=yellow>[AISceneGenerator] Parsing scene JSON:\n{contentJson}</color>");

                // Parse generated scene
                GeneratedScene scene = JsonUtility.FromJson<GeneratedScene>(contentJson);

                if (scene == null || scene.props == null)
                {
                    onError?.Invoke("Failed to parse generated scene JSON");
                    yield break;
                }

                if (wasTruncated)
                {
                    Debug.LogWarning($"<color=yellow>[AISceneGenerator] Response was truncated, only generated {scene.props.Count} objects (may be incomplete)</color>");
                }

                Debug.Log($"<color=green>[AISceneGenerator] Successfully generated {scene.props.Count} objects!</color>");

                onSuccess?.Invoke(scene);
            }
            catch (System.Exception e)
            {
                string errorMsg = $"Failed to parse OpenAI response: {e.Message}\n{responseText}";
                Debug.LogError($"<color=red>[AISceneGenerator] {errorMsg}</color>");
                onError?.Invoke(errorMsg);
            }
        }

        private string BuildOpenAIRequest(string userPrompt, Vector3Int volumeSize, Vector3 volumeCenter, List<ExistingObjectInfo> existingObjects)
        {
            // Read pre-generated JSON from TextAsset
            string assetsJson = assetCatalogJsonFile.text;

            if (string.IsNullOrEmpty(assetsJson))
            {
                Debug.LogError("<color=red>[AISceneGenerator] AssetCatalog JSON file is empty!</color>");
                return null;
            }

            // Log first time
            if (logApiCalls)
            {
                Debug.Log($"<color=green>[AISceneGenerator] Using pre-generated JSON ({assetsJson.Length} characters)</color>");
            }

            // Each volume unit is 8m x 8m x 8m
            const float VOLUME_UNIT_SIZE = 8f;

            // Calculate actual world size in meters
            float worldSizeX = volumeSize.x * VOLUME_UNIT_SIZE;
            float worldSizeY = volumeSize.y * VOLUME_UNIT_SIZE;
            float worldSizeZ = volumeSize.z * VOLUME_UNIT_SIZE;

            // Calculate floor Y position (ground is at bottom of volume)
            float floorY = -(worldSizeY / 2f);

            // Calculate recommended object count per 8x8x8m grid
            int numGrids = volumeSize.x * volumeSize.y * volumeSize.z;
            int minObjectsPerGrid = 30;  // Minimum 30 objects per grid
            int maxObjectsPerGrid = 50;  // Maximum 50 objects per grid
            int minTotalObjects = numGrids * minObjectsPerGrid;
            int maxTotalObjects = numGrids * maxObjectsPerGrid;

            // Calculate position range (centered on volumeCenter)
            float halfX = worldSizeX / 2f;
            float halfZ = worldSizeZ / 2f;

            // Build existing objects JSON
            string existingObjectsJson = "";
            if (existingObjects != null && existingObjects.Count > 0)
            {
                ExistingObjectsData existingData = new ExistingObjectsData { objects = existingObjects };
                existingObjectsJson = JsonUtility.ToJson(existingData, false);
            }

            // Build system prompt
            string outputFormatExample = @"{
  ""props"": [
    {
      ""name"": ""sofa_modern"",  // MUST be exact name from asset list!
      ""position"": [0, 0, 0],
      ""rotation"": [0, 90, 0],
      ""scale"": [1, 1, 1]
    }
  ]
}

FOR DELETE (when user says 'delete' or 'remove'):
{
  ""props"": [
    {
      ""deleteObjectName"": ""bed""  // ONLY this field! NO position/rotation/scale/name!
    }
  ]
}";

            string systemPrompt = $@"3D scene designer. Generate, modify, or DELETE objects in JSON.

⚠️ CRITICAL RULES:
1. Use EXACT asset names from AVAILABLE ASSETS list (copy exact 'n' field)
2. DO NOT invent asset names
3. If scene has existing objects: Generate ONLY new requested items, DO NOT regenerate existing ones
4. Count: Generate {minTotalObjects}-{maxTotalObjects} total objects (min 30 per grid)
5. No overlap, check 's' field for size. Floor Y={floorY:F1}m
6. VARIETY: Use different assets, avoid duplicates (max 2-3 of same item)
7. Output JSON only, no markdown
8. DELETE: If user says 'delete' or 'remove', use deleteObjectName field ONLY (no other fields!)

OUTPUT FORMAT:
{outputFormatExample}";

            // Build user prompt
            string existingObjectsSection = "";
            bool hasExistingObjects = existingObjects != null && existingObjects.Count > 0;

            if (hasExistingObjects)
            {
                existingObjectsSection = $@"

⚠️⚠️⚠️ CRITICAL: SCENE ALREADY HAS {existingObjects.Count} OBJECTS ⚠️⚠️⚠️
These objects ALREADY EXIST in the scene. DO NOT include them in your output!

EXISTING OBJECTS (DO NOT REGENERATE THESE):
{existingObjectsJson}

YOUR TASK:
- Generate ONLY NEW objects that the user requests
- DO NOT copy/regenerate the existing objects above
- Avoid overlapping with existing object positions
- Leave 0.5m+ clearance around existing objects

EXAMPLES:
✅ ADD: ""add a TV"" → {{""props"":[{{""name"":""TV Modern"",""position"":[2,0,0],""rotation"":[0,0,0],""scale"":[1,1,1]}}]}}
✅ DELETE: ""delete the sofa"" → {{""props"":[{{""deleteObjectName"":""sofa""}}]}}
   ⚠️ DELETE RULES: Only include deleteObjectName field! NO position, rotation, scale, or name!
✅ REPLACE: ""replace the bed"" → {{""props"":[{{""name"":""Bed Modern"",""position"":[2,0,0],""rotation"":[0,0,0],""scale"":[1,1,1],""replaceObjectName"":""bed""}}]}}
❌ WRONG: Copying existing objects
❌ WRONG: Regenerating objects that already exist
❌ WRONG DELETE: {{""deleteObjectName"":""sofa"",""position"":[0,0,0]}} (DO NOT include other fields!)";
            }

            // Adjust object count if there are existing objects
            string countInstruction;
            if (hasExistingObjects)
            {
                countInstruction = "Generate ONLY what user requests (e.g., 'add a TV' = 1 TV, 'add some plants' = 2-4 plants)";
            }
            else
            {
                countInstruction = $"{minTotalObjects}-{maxTotalObjects} total objects (minimum 30 per grid, mix of large and small items)";
            }

            string userMessage = $@"REQUEST: {userPrompt}

SPACE: {worldSizeX:F1}×{worldSizeY:F1}×{worldSizeZ:F1}m, X:[{-halfX:F1},{+halfX:F1}] Y:[{floorY:F1},{-floorY:F1}] Z:[{-halfZ:F1},{+halfZ:F1}]
COUNT: {countInstruction}
{existingObjectsSection}
ASSETS (a=list, n=name, s=[w,h,d]):
{assetsJson}

⚠️ REMINDERS:
- Use EXACT 'n' from above
- Maximize variety: Use different assets, limit duplicates to 2-3 max per item
- Create diverse, interesting scenes with varied objects";

            // Build OpenAI request
            OpenAIRequest openAIRequest = new OpenAIRequest
            {
                model = openAIModel,
                messages = new Message[]
                {
                    new Message { role = "system", content = systemPrompt },
                    new Message { role = "user", content = userMessage }
                },
                temperature = 0.7f,
                max_tokens = 16000  // Increased for larger scenes (gpt-4o-mini supports 16k output)
            };

            return JsonUtility.ToJson(openAIRequest);
        }

        /// <summary>
        /// Fix common JSON formatting errors from LLM responses
        /// </summary>
        private string FixCommonJsonErrors(string json)
        {
            // Fix = instead of : (e.g., "position=[0, 1, 2]" → "position": [0, 1, 2])
            json = System.Text.RegularExpressions.Regex.Replace(
                json,
                @"""(\w+)=([^\n""]+)""",
                @"""$1"": $2"
            );

            // Fix missing quotes after field names (e.g., "position: [" → "position": [)
            // This regex finds patterns like: "fieldName: value
            // and replaces with: "fieldName": value
            json = System.Text.RegularExpressions.Regex.Replace(
                json,
                @"""(\w+):\s*([^\n""]+)",
                @"""$1"": $2"
            );

            Debug.Log($"<color=cyan>[AISceneGenerator] Applied JSON error fixes</color>");

            return json;
        }

        /// <summary>
        /// Attempt to fix truncated JSON by closing open arrays/objects
        /// </summary>
        private string FixTruncatedJson(string truncatedJson)
        {
            // Count open braces and brackets
            int openBraces = 0;
            int openBrackets = 0;
            bool inString = false;
            bool escaped = false;

            foreach (char c in truncatedJson)
            {
                if (escaped)
                {
                    escaped = false;
                    continue;
                }

                if (c == '\\')
                {
                    escaped = true;
                    continue;
                }

                if (c == '"')
                {
                    inString = !inString;
                    continue;
                }

                if (!inString)
                {
                    if (c == '{') openBraces++;
                    if (c == '}') openBraces--;
                    if (c == '[') openBrackets++;
                    if (c == ']') openBrackets--;
                }
            }

            // Close incomplete structures
            string fixedJson = truncatedJson;

            // If we're in the middle of a string, close it
            if (inString)
            {
                fixedJson += "\"";
            }

            // Close any incomplete object in the array
            if (openBraces > openBrackets)
            {
                fixedJson += "}";
            }

            // Close the props array
            for (int i = 0; i < openBrackets; i++)
            {
                fixedJson += "]";
            }

            // Close the root object
            for (int i = 0; i < openBraces - openBrackets; i++)
            {
                fixedJson += "}";
            }

            Debug.Log($"<color=cyan>[AISceneGenerator] Fixed JSON: {fixedJson.Substring(System.Math.Max(0, fixedJson.Length - 100))}</color>");

            return fixedJson;
        }

        // ===== Data Structures =====

        [System.Serializable]
        public class GeneratedScene
        {
            public List<PropData> props;
        }

        [System.Serializable]
        public class PropData
        {
            public string name;  // Asset displayName (changed from assetId to save tokens)
            public float[] position;
            public float[] rotation;
            public float[] scale;
            public string replaceObjectName;  // Optional: if set, this object replaces an existing one
            public string deleteObjectName;   // Optional: if set, delete this existing object (leave other fields empty)
        }

        [System.Serializable]
        public class ExistingObjectInfo
        {
            public string assetId;
            public string objectName;
            public float[] position;  // Relative to volume center
            public float[] boundingBoxSize;
            public string objectType;  // "PlacedObject", "SmartTerrain", etc.
        }

        [System.Serializable]
        private class ExistingObjectsData
        {
            public List<ExistingObjectInfo> objects;
        }

        [System.Serializable]
        private class OpenAIRequest
        {
            public string model;
            public Message[] messages;
            public float temperature;
            public int max_tokens;
        }

        [System.Serializable]
        private class Message
        {
            public string role;
            public string content;
        }

        [System.Serializable]
        private class OpenAIResponse
        {
            public Choice[] choices;
        }

        [System.Serializable]
        private class Choice
        {
            public Message message;
            public string finish_reason;
        }

        /// <summary>
        /// Convert AssetCatalog to JSON for OpenAI API - sends ALL assets for maximum flexibility
        /// </summary>
        // Note: JSON generation is now done by the Editor tool "Asset Catalog JSON Exporter"
        // The runtime simply reads the pre-generated JSON file
    }
}
