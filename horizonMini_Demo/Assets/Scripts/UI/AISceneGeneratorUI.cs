using UnityEngine;
using UnityEngine.UI;
using TMPro;
using HorizonMini.Build;
using HorizonMini.Controllers;
using HorizonMini.AI;
using HorizonMini.Core;
using HorizonMini.Data;
using System.Collections.Generic;
using System;

namespace HorizonMini.UI
{
    /// <summary>
    /// AI Scene Generator UI - Simple prompt input and generate button
    /// </summary>
    public class AISceneGeneratorUI : MonoBehaviour
    {
        [Header("References")]
        [SerializeField] private BuildController buildController;
        [SerializeField] private AISceneGenerator aiSceneGenerator;
        [SerializeField] private AssetCatalog assetCatalog;

        [Header("UI Elements")]
        [SerializeField] private GameObject panel;
        [SerializeField] private Button closeButton;

        [Header("Prompt Input")]
        [SerializeField] private TMP_InputField promptInputField;
        [SerializeField] private Button generateButton;
        [SerializeField] private TextMeshProUGUI statusText;

        private void Start()
        {
            Debug.Log("AISceneGeneratorUI Start() called");

            // Setup close button
            if (closeButton != null)
            {
                closeButton.onClick.AddListener(Hide);
            }

            // Setup generate button
            if (generateButton != null)
            {
                generateButton.onClick.AddListener(OnGenerateClicked);
            }

            // Start hidden
            Hide();
        }

        private void OnGenerateClicked()
        {
            Debug.Log("[AISceneGenerator] Generate button clicked!");

            if (promptInputField == null)
            {
                Debug.LogError("[AISceneGenerator] Prompt input field not assigned!");
                UpdateStatus("Error: Input field not assigned");
                return;
            }

            string prompt = promptInputField.text;
            Debug.Log($"[AISceneGenerator] Prompt text: '{prompt}'");

            if (string.IsNullOrEmpty(prompt))
            {
                UpdateStatus("Please enter a prompt");
                Debug.LogWarning("[AISceneGenerator] Prompt is empty");
                return;
            }

            if (aiSceneGenerator == null)
            {
                Debug.LogError("[AISceneGenerator] AISceneGenerator component not assigned!");
                UpdateStatus("Error: AI generator not configured");
                return;
            }

            if (buildController == null)
            {
                Debug.LogError("[AISceneGenerator] BuildController not assigned!");
                UpdateStatus("Error: Build controller not found");
                return;
            }

            // Get current volume grid size
            VolumeGrid volumeGrid = buildController.VolumeGrid;
            if (volumeGrid == null)
            {
                UpdateStatus("Error: No volume grid found");
                Debug.LogError("[AISceneGenerator] No volume grid in build controller");
                return;
            }

            Vector3Int volumeSize = volumeGrid.volumeDimensions;
            Vector3 volumeCenter = volumeGrid.GetCenter();

            // Disable generate button during generation
            if (generateButton != null)
            {
                generateButton.interactable = false;
            }

            UpdateStatus("Generating scene...");
            Debug.Log($"<color=cyan>[AISceneGenerator] USER PROMPT: {prompt}</color>");
            Debug.Log($"<color=cyan>[AISceneGenerator] VOLUME SIZE: {volumeSize}</color>");
            Debug.Log($"<color=cyan>[AISceneGenerator] VOLUME CENTER: {volumeCenter}</color>");

            // Note: Walls are now generated by the user manually using SmartInnerWall
            // No longer auto-generating walls

            // Detect existing PlacedObjects in the scene
            List<AISceneGenerator.ExistingObjectInfo> existingObjects = DetectExistingObjects(volumeCenter);

            if (existingObjects.Count > 0)
            {
                Debug.Log($"<color=yellow>[AISceneGenerator] Found {existingObjects.Count} existing objects in scene</color>");
            }

            // Call AI generation
            aiSceneGenerator.GenerateScene(
                prompt,
                volumeSize,
                volumeCenter,
                OnGenerationSuccess,
                OnGenerationError,
                existingObjects
            );
        }

        private void OnGenerationSuccess(AISceneGenerator.GeneratedScene scene)
        {
            Debug.Log($"<color=green>[AISceneGenerator] Generation successful! {scene.props.Count} objects</color>");

            UpdateStatus($"Success! Generated {scene.props.Count} objects");

            // Debug: Show first 5 AI-generated asset names
            Debug.Log($"<color=magenta>========== AI RETURNED ASSET NAMES (first 5) ==========</color>");
            for (int i = 0; i < Mathf.Min(5, scene.props.Count); i++)
            {
                Debug.Log($"<color=magenta>  AI name [{i}]: '{scene.props[i].name}'</color>");
            }

            // Debug: Show first 5 catalog asset IDs
            if (assetCatalog != null)
            {
                var catalogAssets = assetCatalog.GetAllAssets();
                Debug.Log($"<color=cyan>========== CATALOG ASSET NAMES (first 5) ==========</color>");
                for (int i = 0; i < Mathf.Min(5, catalogAssets.Count); i++)
                {
                    Debug.Log($"<color=cyan>  Catalog name [{i}]: '{catalogAssets[i].displayName}'</color>");
                }
            }

            // Instantiate objects in the scene
            InstantiateGeneratedScene(scene);

            // Re-enable generate button
            if (generateButton != null)
            {
                generateButton.interactable = true;
            }

            // Auto-close panel after success
            Invoke("Hide", 2f);
        }

        private void OnGenerationError(string error)
        {
            Debug.LogError($"<color=red>[AISceneGenerator] Generation failed: {error}</color>");

            UpdateStatus($"Error: {error}");

            // Re-enable generate button
            if (generateButton != null)
            {
                generateButton.interactable = true;
            }
        }

        private void InstantiateGeneratedScene(AISceneGenerator.GeneratedScene scene)
        {
            if (buildController == null)
            {
                Debug.LogError("[AISceneGenerator] BuildController not assigned, cannot instantiate objects");
                return;
            }

            // Get volume center for offset
            VolumeGrid volumeGrid = buildController.VolumeGrid;
            if (volumeGrid == null)
            {
                Debug.LogError("[AISceneGenerator] No volume grid found");
                return;
            }

            Vector3 volumeCenter = volumeGrid.GetCenter();

            // Get AssetCatalog to lookup prefabs
            AISceneGenerator generator = aiSceneGenerator;
            if (generator == null)
            {
                Debug.LogError("[AISceneGenerator] Cannot find AssetCatalog");
                return;
            }

            // Validate AssetCatalog reference
            if (assetCatalog == null)
            {
                Debug.LogError("[AISceneGenerator] AssetCatalog not assigned in AISceneGeneratorUI");
                return;
            }

            // Find highest terrain surface in the scene (in world coordinates)
            float terrainTopWorldY = FindHighestTerrainSurface(volumeCenter);

            int instantiatedCount = 0;
            int replacedCount = 0;
            int deletedCount = 0;
            int errorCount = 0;

            foreach (var propData in scene.props)
            {
                // Check if this is a delete operation
                if (!string.IsNullOrEmpty(propData.deleteObjectName))
                {
                    bool deleted = DeleteExistingObject(propData.deleteObjectName);
                    if (deleted)
                    {
                        deletedCount++;
                        Debug.Log($"<color=green>[AISceneGenerator] Successfully deleted {propData.deleteObjectName}</color>");
                    }
                    else
                    {
                        Debug.LogWarning($"<color=yellow>[AISceneGenerator] Could not find object to delete: {propData.deleteObjectName}</color>");
                        errorCount++;
                    }
                    continue;
                }

                // Check if this is a replacement operation
                if (!string.IsNullOrEmpty(propData.replaceObjectName))
                {
                    bool replaced = ReplaceExistingObject(propData, assetCatalog, volumeCenter);
                    if (replaced)
                    {
                        replacedCount++;
                        Debug.Log($"<color=green>[AISceneGenerator] Successfully replaced {propData.replaceObjectName} with {propData.name}</color>");
                    }
                    else
                    {
                        Debug.LogWarning($"<color=yellow>[AISceneGenerator] Could not find object to replace: {propData.replaceObjectName}</color>");
                        errorCount++;
                    }
                    continue;
                }

                // Map name to asset (name-to-assetId mapping to save JSON tokens)
                PlaceableAsset assetInfo = null;

                // Try exact displayName match first
                foreach (var asset in assetCatalog.GetAllAssets())
                {
                    if (asset.displayName == propData.name)
                    {
                        assetInfo = asset;
                        break;
                    }
                }

                // Fallback: If exact name not found, try fuzzy matching
                if (assetInfo == null)
                {
                    Debug.LogWarning($"<color=yellow>[AISceneGenerator] Asset name not found: '{propData.name}', attempting fuzzy match...</color>");
                    assetInfo = FuzzyMatchAsset(assetCatalog, propData.name);

                    if (assetInfo != null)
                    {
                        Debug.Log($"<color=cyan>[AISceneGenerator] Fuzzy matched '{propData.name}' → '{assetInfo.displayName}' ({assetInfo.assetId})</color>");
                    }
                    else
                    {
                        Debug.LogWarning($"<color=red>[AISceneGenerator] No match found for: '{propData.name}'</color>");
                        errorCount++;
                        continue;
                    }
                }

                if (assetInfo.prefab == null)
                {
                    Debug.LogWarning($"<color=red>[AISceneGenerator] Asset '{propData.name}' has no prefab assigned</color>");
                    errorCount++;
                    continue;
                }

                // Parse position, rotation, scale
                // AI generates positions relative to volume center (0,0,0)
                // Add volumeCenter to get world position
                Vector3 relativePosition = new Vector3(propData.position[0], propData.position[1], propData.position[2]);
                Vector3 worldPosition = volumeCenter + relativePosition;

                Vector3 scale = new Vector3(propData.scale[0], propData.scale[1], propData.scale[2]);

                // Instantiate prefab
                GameObject instance = Instantiate(assetInfo.prefab);
                instance.transform.position = worldPosition;
                instance.transform.localScale = scale;
                instance.name = assetInfo.displayName;

                // Check if this is a wall-mounted object (contains keywords like "painting", "picture", "mirror", "lamp")
                bool isWallMounted = IsWallMountedObject(assetInfo);

                // Calculate rotation to face volume center
                // Objects should face the center point, snapped to 90-degree increments
                float targetYRotation = CalculateRotationToCenter(relativePosition);
                instance.transform.rotation = Quaternion.Euler(0, targetYRotation, 0);

                Debug.Log($"<color=cyan>[AISceneGenerator] {assetInfo.displayName} rotated to {targetYRotation}° to face center</color>");

                // If there's terrain and this is NOT a wall-mounted object, snap to terrain surface
                if (terrainTopWorldY != float.MinValue && !isWallMounted)
                {
                    Vector3 snappedPosition = instance.transform.position;
                    snappedPosition.y = terrainTopWorldY;  // Use world Y coordinate
                    instance.transform.position = snappedPosition;

                    // Calculate relative Y for logging
                    float relativeTerrainY = terrainTopWorldY - volumeCenter.y;
                    Debug.Log($"<color=green>[AISceneGenerator] Snapped {assetInfo.displayName} to terrain surface at world Y={terrainTopWorldY:F2} (relative Y={relativeTerrainY:F2})</color>");
                }

                // Add PlacedObject component to make it editable
                PlacedObject placedObject = instance.AddComponent<PlacedObject>();
                // Use assetId directly (AssetCatalog system)
                placedObject.assetId = assetInfo.assetId;
                placedObject.objectId = System.Guid.NewGuid().ToString();
                placedObject.sourceAsset = null; // AI generated objects don't have PlaceableAsset reference
                placedObject.UpdateSavedTransform();

                // Register with BuildController so it gets saved
                buildController.RegisterPlacedObject(placedObject);

                // Parent to build container
                if (buildController.VolumeGrid != null)
                {
                    instance.transform.SetParent(buildController.VolumeGrid.transform.parent);
                }

                instantiatedCount++;

                Debug.Log($"<color=green>[AISceneGenerator] Instantiated PlacedObject: {propData.name} at world position {worldPosition} (relative: {relativePosition})</color>");
            }

            Debug.Log($"<color=green>[AISceneGenerator] Instantiated {instantiatedCount} new objects, replaced {replacedCount}, deleted {deletedCount}, {errorCount} errors</color>");
            Debug.Log($"<color=cyan>[AISceneGenerator] Volume center used for offset: {volumeCenter}</color>");

            // Resolve collisions between generated objects
            ResolveCollisions(terrainTopWorldY);

            // Snap wall-mounted objects to walls or remove if can't attach
            SnapOrRemoveWallMountedObjects(volumeCenter);
        }

        /// <summary>
        /// Generate invisible boundary colliders around volume to prevent player from leaving
        /// Can be called externally when entering Play/Browse mode
        /// </summary>
        public void GenerateVolumeBoundaryColliders()
        {
            // Check if boundaries already exist
            GameObject existingBoundaries = GameObject.Find("VolumeBoundaries");
            if (existingBoundaries != null && existingBoundaries)
            {
                Debug.Log("<color=yellow>[AISceneGenerator] Volume boundaries already exist, skipping generation</color>");
                return;
            }

            // Clean up any destroyed boundary references
            if (existingBoundaries != null && !existingBoundaries)
            {
                Debug.Log("<color=yellow>[AISceneGenerator] Found destroyed boundary reference, will recreate</color>");
            }

            if (buildController == null)
            {
                Debug.LogWarning("[AISceneGenerator] BuildController not assigned, cannot generate boundaries");
                return;
            }

            VolumeGrid volumeGrid = buildController.VolumeGrid;
            if (volumeGrid == null)
            {
                Debug.LogWarning("[AISceneGenerator] No volume grid found, cannot generate boundaries");
                return;
            }

            Vector3 volumeCenter = volumeGrid.GetCenter();
            Vector3Int volumeSize = volumeGrid.volumeDimensions;
            const float VOLUME_UNIT_SIZE = 8f;
            const float WALL_THICKNESS = 0.5f;
            const float WALL_HEIGHT_MULTIPLIER = 1.2f; // Make walls slightly taller than volume

            float width = volumeSize.x * VOLUME_UNIT_SIZE;
            float height = volumeSize.y * VOLUME_UNIT_SIZE * WALL_HEIGHT_MULTIPLIER;
            float depth = volumeSize.z * VOLUME_UNIT_SIZE;

            // Create parent container
            GameObject boundariesContainer = new GameObject("VolumeBoundaries");
            boundariesContainer.transform.position = volumeCenter;
            boundariesContainer.transform.SetParent(volumeGrid.transform.parent);

            // Create 4 invisible walls (left, right, front, back)
            CreateBoundaryWall(boundariesContainer.transform, "BoundaryWall_Left",
                new Vector3(-width / 2f, height / 2f, 0),
                new Vector3(WALL_THICKNESS, height, depth));

            CreateBoundaryWall(boundariesContainer.transform, "BoundaryWall_Right",
                new Vector3(width / 2f, height / 2f, 0),
                new Vector3(WALL_THICKNESS, height, depth));

            CreateBoundaryWall(boundariesContainer.transform, "BoundaryWall_Front",
                new Vector3(0, height / 2f, -depth / 2f),
                new Vector3(width, height, WALL_THICKNESS));

            CreateBoundaryWall(boundariesContainer.transform, "BoundaryWall_Back",
                new Vector3(0, height / 2f, depth / 2f),
                new Vector3(width, height, WALL_THICKNESS));

            // Create floor collider
            CreateBoundaryWall(boundariesContainer.transform, "BoundaryFloor",
                new Vector3(0, 0, 0),
                new Vector3(width, 0.1f, depth));

            Debug.Log($"<color=green>[AISceneGenerator] Generated invisible boundary colliders around volume</color>");
        }

        /// <summary>
        /// Create a single invisible boundary wall with box collider
        /// </summary>
        private void CreateBoundaryWall(Transform parent, string name, Vector3 localPosition, Vector3 size)
        {
            GameObject wall = new GameObject(name);
            wall.transform.SetParent(parent);
            wall.transform.localPosition = localPosition;
            wall.transform.localRotation = Quaternion.identity;

            // Add box collider (invisible barrier)
            BoxCollider collider = wall.AddComponent<BoxCollider>();
            collider.size = size;

            // Optional: Add layer tag for easy identification
            wall.layer = LayerMask.NameToLayer("Default");

            Debug.Log($"<color=cyan>[AISceneGenerator] Created boundary wall: {name} at {localPosition} with size {size}</color>");
        }

        /// <summary>
        /// Generate walls for the room (-X and +Z directions)
        /// </summary>
        private void GenerateWalls(Vector3Int volumeSize, Vector3 volumeCenter)
        {
            const float VOLUME_UNIT_SIZE = 8f;
            const float WALL_THICKNESS = 0.5f;

            // Calculate room dimensions
            float roomWidth = volumeSize.x * VOLUME_UNIT_SIZE;
            float roomHeight = volumeSize.y * VOLUME_UNIT_SIZE;
            float roomDepth = volumeSize.z * VOLUME_UNIT_SIZE;

            // Calculate floor position (bottom of volume)
            float floorY = volumeCenter.y - (roomHeight / 2f);

            // Get SmartTerrain prefab from BuildController's AssetCatalog
            if (buildController == null)
            {
                Debug.LogError("[AISceneGenerator] BuildController is null, cannot generate walls");
                return;
            }

            // Validate AssetCatalog reference
            if (assetCatalog == null)
            {
                Debug.LogError("[AISceneGenerator] AssetCatalog not assigned in AISceneGeneratorUI");
                return;
            }

            // Find SmartInnerWall prefab in AssetCatalog
            PlaceableAsset wallAsset = assetCatalog.GetAssetsByCategory(AssetCategory.SmartBuilder)
                .Find(a => a.assetId.Contains("wall") || a.displayName.Contains("Wall"));

            if (wallAsset == null || wallAsset.prefab == null)
            {
                Debug.LogError("[AISceneGenerator] Cannot find SmartInnerWall asset in catalog. Please add it manually to AssetCatalog.");
                return;
            }

            GameObject wallPrefab = wallAsset.prefab;

            // Generate +X wall (right wall)
            {
                float wallX = volumeCenter.x + (roomWidth / 2f);
                Vector3 wallPosition = new Vector3(wallX, floorY, volumeCenter.z);

                GameObject rightWall = Instantiate(wallPrefab);
                rightWall.name = "AI_Wall_Right";
                rightWall.transform.position = wallPosition;

                SmartInnerWall wall = rightWall.GetComponent<SmartInnerWall>();
                if (wall != null)
                {
                    // Control point formula: size = (cp.x * 2, cp.y * 1, cp.z * 2)
                    // We want: thickness=0.5m, height=roomHeight, depth=roomDepth
                    // So: cp.x * 2 = 0.5 → cp.x = 0.25
                    //     cp.y * 1 = roomHeight → cp.y = roomHeight
                    //     cp.z * 2 = roomDepth → cp.z = roomDepth / 2
                    Vector3 controlPoint = new Vector3(0.25f, roomHeight, roomDepth / 2f);
                    wall.SetControlPointPosition(controlPoint, forceImmediate: true);
                }

                // Add PlacedObject component
                PlacedObject placedObj = rightWall.AddComponent<PlacedObject>();
                placedObj.assetId = "AI_Wall";
                placedObj.objectId = System.Guid.NewGuid().ToString();
                placedObj.UpdateSavedTransform();

                // Parent to build container
                if (buildController.VolumeGrid != null)
                {
                    rightWall.transform.SetParent(buildController.VolumeGrid.transform.parent);
                }

                Debug.Log($"<color=green>[AISceneGenerator] Created +X wall at {wallPosition}, size: (0.5 x {roomHeight} x {roomDepth})</color>");
            }

            // Generate +Z wall (back wall)
            {
                float wallZ = volumeCenter.z + (roomDepth / 2f);
                Vector3 wallPosition = new Vector3(volumeCenter.x, floorY, wallZ);

                GameObject backWall = Instantiate(wallPrefab);
                backWall.name = "AI_Wall_Back";
                backWall.transform.position = wallPosition;

                SmartInnerWall wall = backWall.GetComponent<SmartInnerWall>();
                if (wall != null)
                {
                    // Control point formula: size = (cp.x * 2, cp.y * 1, cp.z * 2)
                    // We want: width=roomWidth, height=roomHeight, thickness=0.5m
                    // So: cp.x * 2 = roomWidth → cp.x = roomWidth / 2
                    //     cp.y * 1 = roomHeight → cp.y = roomHeight
                    //     cp.z * 2 = 0.5 → cp.z = 0.25
                    Vector3 controlPoint = new Vector3(roomWidth / 2f, roomHeight, 0.25f);
                    wall.SetControlPointPosition(controlPoint, forceImmediate: true);
                }

                // Add PlacedObject component
                PlacedObject placedObj = backWall.AddComponent<PlacedObject>();
                placedObj.assetId = "AI_Wall";
                placedObj.objectId = System.Guid.NewGuid().ToString();
                placedObj.UpdateSavedTransform();

                // Parent to build container
                if (buildController.VolumeGrid != null)
                {
                    backWall.transform.SetParent(buildController.VolumeGrid.transform.parent);
                }

                Debug.Log($"<color=green>[AISceneGenerator] Created +Z wall at {wallPosition}, size: ({roomWidth} x {roomHeight} x 0.5)</color>");
            }
        }

        /// <summary>
        /// Replace an existing object with a new one
        /// </summary>
        /// <summary>
        /// Delete an existing object by name
        /// </summary>
        private bool DeleteExistingObject(string objectName)
        {
            PlacedObject[] allPlacedObjects = FindObjectsOfType<PlacedObject>();

            foreach (PlacedObject placedObj in allPlacedObjects)
            {
                // Match by name (case-insensitive, partial match)
                if (placedObj.gameObject.name.IndexOf(objectName, System.StringComparison.OrdinalIgnoreCase) >= 0)
                {
                    Debug.Log($"<color=yellow>[AISceneGenerator] Deleting object: {placedObj.gameObject.name}</color>");

                    // Unregister from BuildController
                    if (buildController != null)
                    {
                        buildController.UnregisterPlacedObject(placedObj);
                    }

                    // Destroy the object
                    Destroy(placedObj.gameObject);
                    return true;
                }
            }

            Debug.LogWarning($"[AISceneGenerator] Cannot find object with name: {objectName}");
            return false;
        }

        private bool ReplaceExistingObject(AISceneGenerator.PropData propData, AssetCatalog assetCatalog, Vector3 volumeCenter)
        {
            // Find the object to replace by name
            PlacedObject[] allPlacedObjects = FindObjectsOfType<PlacedObject>();
            PlacedObject targetObject = null;

            foreach (PlacedObject obj in allPlacedObjects)
            {
                if (obj.gameObject.name == propData.replaceObjectName)
                {
                    targetObject = obj;
                    break;
                }
            }

            if (targetObject == null)
            {
                Debug.LogWarning($"[AISceneGenerator] Cannot find object with name: {propData.replaceObjectName}");
                return false;
            }

            // Get the new asset (map name to assetId)
            PlaceableAsset assetInfo = null;
            foreach (var asset in assetCatalog.GetAllAssets())
            {
                if (asset.displayName == propData.name)
                {
                    assetInfo = asset;
                    break;
                }
            }

            if (assetInfo == null || assetInfo.prefab == null)
            {
                Debug.LogWarning($"[AISceneGenerator] Asset not found: {propData.name}");
                return false;
            }

            // Store the old object's transform
            Vector3 oldPosition = targetObject.transform.position;
            Quaternion oldRotation = targetObject.transform.rotation;
            Transform oldParent = targetObject.transform.parent;

            // Calculate rotation to face center (override AI's rotation for consistency)
            Vector3 relativePosition = oldPosition - volumeCenter;
            float targetYRotation = CalculateRotationToCenter(relativePosition);

            // Unregister and destroy old object
            buildController.UnregisterPlacedObject(targetObject);
            Destroy(targetObject.gameObject);

            // Instantiate new object
            GameObject newInstance = Instantiate(assetInfo.prefab);
            newInstance.transform.position = oldPosition;
            newInstance.transform.rotation = Quaternion.Euler(0, targetYRotation, 0);
            newInstance.transform.localScale = new Vector3(propData.scale[0], propData.scale[1], propData.scale[2]);
            newInstance.name = assetInfo.displayName;

            // Add PlacedObject component
            PlacedObject placedObject = newInstance.AddComponent<PlacedObject>();
            // Use assetId directly (AssetCatalog system)
            placedObject.assetId = assetInfo.assetId;
            placedObject.objectId = System.Guid.NewGuid().ToString();
            placedObject.sourceAsset = null; // AI generated objects don't have PlaceableAsset reference
            placedObject.UpdateSavedTransform();

            // Register with BuildController
            buildController.RegisterPlacedObject(placedObject);

            // Parent to same container
            if (oldParent != null)
            {
                newInstance.transform.SetParent(oldParent);
            }

            Debug.Log($"<color=magenta>[AISceneGenerator] Replaced '{propData.replaceObjectName}' with '{assetInfo.displayName}' at position {oldPosition}</color>");

            return true;
        }

        private void UpdateStatus(string message)
        {
            if (statusText != null)
            {
                statusText.text = message;
            }
            Debug.Log($"[AISceneGenerator] Status: {message}");
        }

        public void Show()
        {
            Debug.Log("[AISceneGeneratorUI] Show() called");

            if (panel != null)
            {
                Debug.Log("[AISceneGeneratorUI] Setting panel active");
                panel.SetActive(true);
            }
            else
            {
                Debug.LogError("[AISceneGeneratorUI] Panel is NULL! Cannot show.");
            }

            // Clear prompt and status
            if (promptInputField != null)
            {
                promptInputField.text = "";
            }
            else
            {
                Debug.LogWarning("[AISceneGeneratorUI] promptInputField is NULL");
            }

            UpdateStatus("");
        }

        public void Hide()
        {
            Debug.Log("[AISceneGeneratorUI] Hide() called");
            if (panel != null)
            {
                panel.SetActive(false);
            }
        }

        public void SetBuildController(BuildController controller)
        {
            buildController = controller;
        }

        /// <summary>
        /// Snap wall-mounted objects to walls, or to volume boundaries if no walls exist
        /// </summary>
        private void SnapOrRemoveWallMountedObjects(Vector3 volumeCenter)
        {
            const float MAX_SNAP_DISTANCE = 2.0f; // Maximum distance to snap to wall
            const float WALL_OFFSET = 0.05f; // Small offset from wall surface

            Debug.Log($"<color=cyan>[AISceneGenerator] Checking wall-mounted objects...</color>");

            PlacedObject[] allObjects = FindObjectsOfType<PlacedObject>();

            foreach (PlacedObject obj in allObjects)
            {
                // Skip walls themselves (SmartInnerWall)
                if (obj.GetComponent<SmartInnerWall>() != null)
                    continue;

                // Check if this is a wall-mounted object
                PlaceableAsset assetInfo = null;

                if (assetCatalog != null)
                {
                    assetInfo = assetCatalog.GetAssetById(obj.assetId);
                }

                if (assetInfo == null || !IsWallMountedObject(assetInfo))
                    continue;

                // Try to find nearest wall
                Vector3 position = obj.transform.position;
                RaycastHit hit;
                bool foundWall = false;
                Vector3 snapPosition = position;
                Quaternion snapRotation = obj.transform.rotation;

                // Cast rays in 4 cardinal directions to find walls
                Vector3[] directions = { Vector3.left, Vector3.right, Vector3.forward, Vector3.back };
                float minDistance = MAX_SNAP_DISTANCE;

                foreach (Vector3 direction in directions)
                {
                    if (Physics.Raycast(position, direction, out hit, MAX_SNAP_DISTANCE))
                    {
                        // Check if hit a wall (SmartInnerWall component)
                        if (hit.collider.GetComponent<SmartInnerWall>() != null)
                        {
                            if (hit.distance < minDistance)
                            {
                                minDistance = hit.distance;
                                foundWall = true;

                                // Snap to wall surface
                                snapPosition = hit.point - direction * WALL_OFFSET;

                                // Face away from wall
                                snapRotation = Quaternion.LookRotation(-direction);

                                Debug.Log($"<color=cyan>[AISceneGenerator] Found SmartInnerWall for {obj.gameObject.name} in direction {direction}, distance {hit.distance:F2}</color>");
                            }
                        }
                    }
                }

                if (foundWall)
                {
                    // Snap to wall
                    obj.transform.position = snapPosition;
                    obj.transform.rotation = snapRotation;
                    obj.UpdateSavedTransform();

                    Debug.Log($"<color=green>[AISceneGenerator] Snapped {obj.gameObject.name} to wall at {snapPosition}</color>");
                }
                else
                {
                    // No wall found, snap to volume boundary as fallback
                    SnapToVolumeBoundary(obj, volumeCenter);
                    Debug.Log($"<color=yellow>[AISceneGenerator] No wall found for {obj.gameObject.name}, snapped to volume boundary</color>");
                }
            }
        }

        /// <summary>
        /// Snap wall-mounted object to the nearest volume boundary (acts as a virtual wall)
        /// </summary>
        private void SnapToVolumeBoundary(PlacedObject obj, Vector3 volumeCenter)
        {
            const float WALL_OFFSET = 0.05f;

            // Get volume grid dimensions
            VolumeGrid volumeGrid = buildController.VolumeGrid;
            if (volumeGrid == null) return;

            Vector3Int volumeSize = volumeGrid.volumeDimensions;
            const float VOLUME_UNIT_SIZE = 8f;

            // Calculate volume boundaries
            float halfWidth = (volumeSize.x * VOLUME_UNIT_SIZE) / 2f;
            float halfDepth = (volumeSize.z * VOLUME_UNIT_SIZE) / 2f;

            Vector3 position = obj.transform.position;
            Vector3 relativePos = position - volumeCenter;

            // Find which boundary is closest
            float distToLeft = Mathf.Abs(relativePos.x + halfWidth);
            float distToRight = Mathf.Abs(relativePos.x - halfWidth);
            float distToFront = Mathf.Abs(relativePos.z + halfDepth);
            float distToBack = Mathf.Abs(relativePos.z - halfDepth);

            float minDist = Mathf.Min(distToLeft, distToRight, distToFront, distToBack);

            Vector3 snapPosition = position;
            Quaternion snapRotation = obj.transform.rotation;

            if (minDist == distToLeft)
            {
                // Snap to left boundary (-X)
                snapPosition.x = volumeCenter.x - halfWidth + WALL_OFFSET;
                snapRotation = Quaternion.Euler(0, 90, 0); // Face right
            }
            else if (minDist == distToRight)
            {
                // Snap to right boundary (+X)
                snapPosition.x = volumeCenter.x + halfWidth - WALL_OFFSET;
                snapRotation = Quaternion.Euler(0, -90, 0); // Face left
            }
            else if (minDist == distToFront)
            {
                // Snap to front boundary (-Z)
                snapPosition.z = volumeCenter.z - halfDepth + WALL_OFFSET;
                snapRotation = Quaternion.Euler(0, 0, 0); // Face forward
            }
            else // distToBack
            {
                // Snap to back boundary (+Z)
                snapPosition.z = volumeCenter.z + halfDepth - WALL_OFFSET;
                snapRotation = Quaternion.Euler(0, 180, 0); // Face backward
            }

            obj.transform.position = snapPosition;
            obj.transform.rotation = snapRotation;
            obj.UpdateSavedTransform();

            Debug.Log($"<color=cyan>[AISceneGenerator] Snapped {obj.gameObject.name} to volume boundary at {snapPosition}</color>");
        }

        /// <summary>
        /// Resolve collisions between all PlacedObjects using separation algorithm
        /// </summary>
        private void ResolveCollisions(float terrainTopWorldY)
        {
            const int MAX_ITERATIONS = 10;
            const float MIN_SEPARATION = 0.1f; // Minimum clearance between objects

            Debug.Log($"<color=cyan>[AISceneGenerator] Starting collision resolution...</color>");

            // Get all non-terrain PlacedObjects
            PlacedObject[] allObjects = FindObjectsOfType<PlacedObject>();
            List<PlacedObject> movableObjects = new List<PlacedObject>();

            foreach (PlacedObject obj in allObjects)
            {
                // Skip terrain and wall objects (they are static)
                if (obj.GetComponent<SmartTerrain>() != null ||
                    obj.GetComponent<SmartTerrainChunk>() != null ||
                    obj.GetComponent<SmartInnerWall>() != null)
                    continue;

                movableObjects.Add(obj);
            }

            if (movableObjects.Count < 2)
            {
                Debug.Log($"<color=yellow>[AISceneGenerator] Less than 2 movable objects, skipping collision resolution</color>");
                return;
            }

            // Perform separation iterations
            for (int iteration = 0; iteration < MAX_ITERATIONS; iteration++)
            {
                bool hadCollision = false;

                for (int i = 0; i < movableObjects.Count; i++)
                {
                    if (movableObjects[i] == null) continue;

                    for (int j = i + 1; j < movableObjects.Count; j++)
                    {
                        if (movableObjects[j] == null) continue;

                        // Check if objects overlap
                        if (CheckOverlap(movableObjects[i], movableObjects[j], out Vector3 separation))
                        {
                            hadCollision = true;

                            // Separate objects (push both away from each other)
                            Vector3 halfSeparation = separation * 0.5f;
                            movableObjects[i].transform.position += halfSeparation;
                            movableObjects[j].transform.position -= halfSeparation;

                            // Snap back to terrain surface if needed (but NOT for wall-mounted objects)
                            if (terrainTopWorldY != float.MinValue)
                            {
                                // Check if object i is wall-mounted
                                bool obj1IsWallMounted = false;
                                if (assetCatalog != null)
                                {
                                    PlaceableAsset asset1 = assetCatalog.GetAssetById(movableObjects[i].assetId);
                                    if (asset1 != null) obj1IsWallMounted = IsWallMountedObject(asset1);
                                }

                                if (!obj1IsWallMounted)
                                {
                                    Vector3 pos1 = movableObjects[i].transform.position;
                                    pos1.y = terrainTopWorldY;
                                    movableObjects[i].transform.position = pos1;
                                }

                                // Check if object j is wall-mounted
                                bool obj2IsWallMounted = false;
                                if (assetCatalog != null)
                                {
                                    PlaceableAsset asset2 = assetCatalog.GetAssetById(movableObjects[j].assetId);
                                    if (asset2 != null) obj2IsWallMounted = IsWallMountedObject(asset2);
                                }

                                if (!obj2IsWallMounted)
                                {
                                    Vector3 pos2 = movableObjects[j].transform.position;
                                    pos2.y = terrainTopWorldY;
                                    movableObjects[j].transform.position = pos2;
                                }
                            }

                            Debug.Log($"<color=yellow>[AISceneGenerator] Iteration {iteration + 1}: Separated {movableObjects[i].gameObject.name} and {movableObjects[j].gameObject.name}</color>");
                        }
                    }
                }

                if (!hadCollision)
                {
                    Debug.Log($"<color=green>[AISceneGenerator] Collision resolution completed in {iteration + 1} iterations</color>");
                    return;
                }
            }

            // After max iterations, remove smaller objects that still overlap
            Debug.LogWarning($"<color=orange>[AISceneGenerator] Max iterations reached, removing overlapping objects...</color>");

            List<PlacedObject> objectsToRemove = new List<PlacedObject>();

            for (int i = 0; i < movableObjects.Count; i++)
            {
                if (movableObjects[i] == null || objectsToRemove.Contains(movableObjects[i])) continue;

                for (int j = i + 1; j < movableObjects.Count; j++)
                {
                    if (movableObjects[j] == null || objectsToRemove.Contains(movableObjects[j])) continue;

                    if (CheckOverlap(movableObjects[i], movableObjects[j], out _))
                    {
                        // Remove the smaller object
                        Vector3 size1 = CalculateBoundingBox(movableObjects[i].gameObject);
                        Vector3 size2 = CalculateBoundingBox(movableObjects[j].gameObject);

                        float volume1 = size1.x * size1.y * size1.z;
                        float volume2 = size2.x * size2.y * size2.z;

                        PlacedObject toRemove = (volume1 < volume2) ? movableObjects[i] : movableObjects[j];
                        objectsToRemove.Add(toRemove);

                        Debug.LogWarning($"<color=red>[AISceneGenerator] Removing {toRemove.gameObject.name} (smaller object, still overlapping)</color>");
                    }
                }
            }

            // Actually destroy the objects
            foreach (PlacedObject obj in objectsToRemove)
            {
                if (obj != null)
                {
                    buildController.UnregisterPlacedObject(obj);
                    Destroy(obj.gameObject);
                }
            }

            if (objectsToRemove.Count > 0)
            {
                Debug.Log($"<color=orange>[AISceneGenerator] Removed {objectsToRemove.Count} overlapping objects</color>");
            }
            else
            {
                Debug.Log($"<color=green>[AISceneGenerator] All collisions resolved</color>");
            }
        }

        /// <summary>
        /// Check if two objects overlap using Colliders (more accurate than AABB)
        /// </summary>
        private bool CheckOverlap(PlacedObject obj1, PlacedObject obj2, out Vector3 separationVector)
        {
            separationVector = Vector3.zero;

            // Get or add colliders
            Collider collider1 = EnsureCollider(obj1.gameObject);
            Collider collider2 = EnsureCollider(obj2.gameObject);

            if (collider1 == null || collider2 == null)
            {
                Debug.LogWarning($"[AISceneGenerator] Missing collider on {obj1?.gameObject.name} or {obj2?.gameObject.name}");
                return false;
            }

            // Use Physics.ComputePenetration for accurate collision detection
            Vector3 direction;
            float distance;

            bool isOverlapping = Physics.ComputePenetration(
                collider1, collider1.transform.position, collider1.transform.rotation,
                collider2, collider2.transform.position, collider2.transform.rotation,
                out direction, out distance
            );

            if (isOverlapping)
            {
                // Only separate on horizontal plane (XZ), keep Y unchanged
                direction.y = 0;
                if (direction.magnitude < 0.01f)
                {
                    // Fallback to position-based direction
                    Vector3 delta = obj2.transform.position - obj1.transform.position;
                    delta.y = 0;

                    if (delta.magnitude < 0.01f)
                    {
                        // Use random direction if at same position
                        direction = new Vector3(UnityEngine.Random.Range(-1f, 1f), 0, UnityEngine.Random.Range(-1f, 1f));
                    }
                    else
                    {
                        direction = delta;
                    }
                }

                direction.Normalize();

                // Calculate separation with extra clearance
                separationVector = direction * (distance + 0.1f); // Add 10cm clearance

                return true;
            }

            return false;
        }

        /// <summary>
        /// Ensure object has a collider, create one if missing
        /// </summary>
        private Collider EnsureCollider(GameObject obj)
        {
            // Check for existing collider
            Collider existing = obj.GetComponent<Collider>();
            if (existing != null)
                return existing;

            // Check in children
            existing = obj.GetComponentInChildren<Collider>();
            if (existing != null)
                return existing;

            // Create a BoxCollider based on renderers
            Renderer[] renderers = obj.GetComponentsInChildren<Renderer>();
            if (renderers.Length == 0)
            {
                Debug.LogWarning($"[AISceneGenerator] No renderers found on {obj.name}, cannot create collider");
                return null;
            }

            // Calculate combined bounds
            Bounds combinedBounds = renderers[0].bounds;
            foreach (Renderer renderer in renderers)
            {
                combinedBounds.Encapsulate(renderer.bounds);
            }

            // Add BoxCollider
            BoxCollider boxCollider = obj.AddComponent<BoxCollider>();

            // Set collider size and center based on renderers
            // Convert world bounds to local space
            Vector3 localCenter = obj.transform.InverseTransformPoint(combinedBounds.center);
            Vector3 localSize = obj.transform.InverseTransformVector(combinedBounds.size);

            boxCollider.center = localCenter;
            boxCollider.size = new Vector3(
                Mathf.Abs(localSize.x),
                Mathf.Abs(localSize.y),
                Mathf.Abs(localSize.z)
            );

            Debug.Log($"<color=cyan>[AISceneGenerator] Created BoxCollider for {obj.name}: center={localCenter}, size={localSize}</color>");

            return boxCollider;
        }

        /// <summary>
        /// Calculate Y rotation to face volume center, snapped to 90-degree increments
        /// </summary>
        private float CalculateRotationToCenter(Vector3 relativePosition)
        {
            // If object is at center, default to 0
            if (relativePosition.magnitude < 0.01f)
            {
                return 0f;
            }

            // Calculate angle from object to center (center is at 0,0,0 in relative space)
            // We want object to face center, so we calculate direction from object to center
            Vector3 directionToCenter = -relativePosition; // Negate because we want to face center
            directionToCenter.y = 0; // Only consider horizontal rotation

            // Calculate angle in degrees
            float angleToCenter = Mathf.Atan2(directionToCenter.x, directionToCenter.z) * Mathf.Rad2Deg;

            // Snap to nearest 90-degree increment
            float snappedAngle = Mathf.Round(angleToCenter / 90f) * 90f;

            // Normalize to 0-360 range
            if (snappedAngle < 0)
            {
                snappedAngle += 360f;
            }

            return snappedAngle;
        }

        /// <summary>
        /// Find the highest terrain surface Y position in the scene (returns world Y coordinate)
        /// Ignores SmartInnerWall - only considers SmartTerrain
        /// </summary>
        private float FindHighestTerrainSurface(Vector3 volumeCenter)
        {
            float highestWorldY = float.MinValue;

            // Find all SmartTerrain objects (but NOT SmartInnerWall)
            PlacedObject[] placedObjects = FindObjectsOfType<PlacedObject>();

            foreach (PlacedObject placedObj in placedObjects)
            {
                // Skip SmartInnerWall objects
                if (placedObj.GetComponent<SmartInnerWall>() != null)
                {
                    continue;
                }

                SmartTerrain terrain = placedObj.GetComponent<SmartTerrain>();
                if (terrain != null)
                {
                    Vector3 terrainSize = terrain.GetSize();
                    Vector3 terrainWorldPos = placedObj.transform.position;

                    // SmartTerrain mesh extends from Y=0 (bottom) to Y=size.y (top) in local space
                    // So top surface in world space is: worldPos.y + size.y
                    float terrainTopWorldY = terrainWorldPos.y + terrainSize.y;

                    if (terrainTopWorldY > highestWorldY)
                    {
                        highestWorldY = terrainTopWorldY;
                    }

                    // Calculate relative position for logging
                    Vector3 relativePos = terrainWorldPos - volumeCenter;
                    float relativeTopY = terrainTopWorldY - volumeCenter.y;

                    Debug.Log($"<color=yellow>[AISceneGenerator] Found SmartTerrain:</color>");
                    Debug.Log($"  World pos: {terrainWorldPos}, Relative pos: {relativePos}");
                    Debug.Log($"  Size: {terrainSize.y:F2}m, Top surface: world Y={terrainTopWorldY:F2}, relative Y={relativeTopY:F2}");
                }

                SmartTerrainChunk chunk = placedObj.GetComponent<SmartTerrainChunk>();
                if (chunk != null)
                {
                    Vector3 chunkSize = chunk.GetSize();
                    Vector3 chunkWorldPos = placedObj.transform.position;

                    // SmartTerrainChunk mesh extends from Y=0 (bottom) to Y=size.y (top) in local space
                    // So top surface in world space is: worldPos.y + size.y
                    float chunkTopWorldY = chunkWorldPos.y + chunkSize.y;

                    if (chunkTopWorldY > highestWorldY)
                    {
                        highestWorldY = chunkTopWorldY;
                    }

                    // Calculate relative position for logging
                    Vector3 relativePos = chunkWorldPos - volumeCenter;
                    float relativeTopY = chunkTopWorldY - volumeCenter.y;

                    Debug.Log($"<color=yellow>[AISceneGenerator] Found SmartTerrainChunk:</color>");
                    Debug.Log($"  World pos: {chunkWorldPos}, Relative pos: {relativePos}");
                    Debug.Log($"  Size: {chunkSize.y:F2}m, Top surface: world Y={chunkTopWorldY:F2}, relative Y={relativeTopY:F2}");
                }
            }

            if (highestWorldY != float.MinValue)
            {
                float relativeHighestY = highestWorldY - volumeCenter.y;
                Debug.Log($"<color=green>[AISceneGenerator] Highest terrain surface: world Y={highestWorldY:F2}, relative Y={relativeHighestY:F2}</color>");
            }
            else
            {
                Debug.Log($"<color=yellow>[AISceneGenerator] No terrain found in scene</color>");
            }

            return highestWorldY;
        }

        /// <summary>
        /// Attempt to fuzzy match an invented assetId to a real asset by displayName
        /// </summary>
        private PlaceableAsset FuzzyMatchAsset(AssetCatalog catalog, string inventedId)
        {
            // Normalize the invented ID (remove numbers, underscores, make lowercase)
            string normalized = inventedId.ToLower()
                .Replace("_1", "").Replace("_2", "").Replace("_3", "").Replace("_4", "").Replace("_5", "")
                .Replace("_", " ").Trim();

            var allAssets = catalog.GetAllAssets();

            // Try exact displayName match first
            foreach (var asset in allAssets)
            {
                if (asset.displayName.ToLower() == normalized)
                    return asset;
            }

            // Try contains match (e.g., "TV" matches "tv_stand_modern")
            foreach (var asset in allAssets)
            {
                if (asset.displayName.ToLower().Contains(normalized) || normalized.Contains(asset.displayName.ToLower()))
                    return asset;
            }

            // Try keyword extraction (e.g., "Couch_1" → "couch" → match "sofa_modern")
            string[] keywords = normalized.Split(' ');
            foreach (string keyword in keywords)
            {
                if (keyword.Length < 3) continue; // Skip short words

                foreach (var asset in allAssets)
                {
                    if (asset.displayName.ToLower().Contains(keyword))
                        return asset;
                }
            }

            return null; // No match found
        }

        /// <summary>
        /// Check if an asset should be wall-mounted (not snapped to terrain)
        /// </summary>
        private bool IsWallMountedObject(PlaceableAsset assetInfo)
        {
            string name = assetInfo.displayName.ToLower();
            string id = assetInfo.assetId.ToLower();

            // Wall-mounted keywords
            string[] wallKeywords = new string[]
            {
                "painting", "picture", "photo", "mirror", "clock",
                "wall", "sconce", "mounted", "curtain", "drape",
                "window", "frame", "shelf", "cabinet"
            };

            foreach (string keyword in wallKeywords)
            {
                if (name.Contains(keyword) || id.Contains(keyword))
                {
                    Debug.Log($"<color=cyan>[AISceneGenerator] {assetInfo.displayName} identified as wall-mounted object</color>");
                    return true;
                }
            }

            return false;
        }

        /// <summary>
        /// Detect all existing PlacedObjects in the scene (including SmartTerrain)
        /// </summary>
        private List<AISceneGenerator.ExistingObjectInfo> DetectExistingObjects(Vector3 volumeCenter)
        {
            List<AISceneGenerator.ExistingObjectInfo> existingObjects = new List<AISceneGenerator.ExistingObjectInfo>();

            // Find all PlacedObjects in the scene
            PlacedObject[] placedObjects = FindObjectsOfType<PlacedObject>();

            foreach (PlacedObject placedObj in placedObjects)
            {
                // Get bounding box size (do this first to get accurate SmartTerrain size)
                Vector3 boundingBoxSize = CalculateBoundingBox(placedObj.gameObject);

                // Calculate position relative to volume center
                Vector3 worldPosition = placedObj.transform.position;
                Vector3 relativePosition = worldPosition - volumeCenter;

                // Determine object type
                string objectType = "PlacedObject";
                SmartInnerWall innerWall = placedObj.GetComponent<SmartInnerWall>();
                if (innerWall != null)
                {
                    objectType = "SmartInnerWall";
                }

                SmartTerrain smartTerrain = placedObj.GetComponent<SmartTerrain>();
                if (smartTerrain != null)
                {
                    objectType = "SmartTerrain";
                }

                SmartTerrainChunk terrainChunk = placedObj.GetComponent<SmartTerrainChunk>();
                if (terrainChunk != null)
                {
                    objectType = "SmartTerrainChunk";
                }

                // Create ExistingObjectInfo
                AISceneGenerator.ExistingObjectInfo info = new AISceneGenerator.ExistingObjectInfo
                {
                    assetId = placedObj.assetId,
                    objectName = placedObj.gameObject.name,
                    position = new float[] { relativePosition.x, relativePosition.y, relativePosition.z },
                    boundingBoxSize = new float[] { boundingBoxSize.x, boundingBoxSize.y, boundingBoxSize.z },
                    objectType = objectType
                };

                existingObjects.Add(info);

                Debug.Log($"<color=cyan>[AISceneGenerator] Detected {objectType}: {placedObj.gameObject.name} at relative pos {relativePosition}, size {boundingBoxSize}</color>");
            }

            return existingObjects;
        }

        /// <summary>
        /// Calculate bounding box size for a GameObject
        /// </summary>
        private Vector3 CalculateBoundingBox(GameObject obj)
        {
            // Check if it's a SmartInnerWall - use its GetSize() method for accurate size
            SmartInnerWall innerWall = obj.GetComponent<SmartInnerWall>();
            if (innerWall != null)
            {
                Vector3 wallSize = innerWall.GetSize();
                Debug.Log($"<color=yellow>[AISceneGenerator] SmartInnerWall size from GetSize(): {wallSize}</color>");
                return wallSize;
            }

            // Check if it's a SmartTerrain - use its GetSize() method for accurate size
            SmartTerrain smartTerrain = obj.GetComponent<SmartTerrain>();
            if (smartTerrain != null)
            {
                Vector3 terrainSize = smartTerrain.GetSize();
                Debug.Log($"<color=yellow>[AISceneGenerator] SmartTerrain size from GetSize(): {terrainSize}</color>");
                return terrainSize;
            }

            // Check if it's a SmartTerrainChunk
            SmartTerrainChunk terrainChunk = obj.GetComponent<SmartTerrainChunk>();
            if (terrainChunk != null)
            {
                Vector3 chunkSize = terrainChunk.GetSize();
                Debug.Log($"<color=yellow>[AISceneGenerator] SmartTerrainChunk size from GetSize(): {chunkSize}</color>");
                return chunkSize;
            }

            // For regular objects, calculate from renderers
            Renderer[] renderers = obj.GetComponentsInChildren<Renderer>();

            if (renderers.Length == 0)
            {
                // Default size if no renderer
                return new Vector3(1f, 1f, 1f);
            }

            // Calculate combined bounds
            Bounds combinedBounds = renderers[0].bounds;
            foreach (Renderer renderer in renderers)
            {
                combinedBounds.Encapsulate(renderer.bounds);
            }

            return combinedBounds.size;
        }
    }
}
